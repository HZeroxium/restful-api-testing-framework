# src/sequences_visualizer.py
"""
Sequences Visualizer

This tool creates visualizations for operation sequences that were previously
generated by the operation_sequencer_tool.py.

Usage:
    python sequences_visualizer.py --input output/operation_sequences/20250529_142727/operation_sequences.json --output visualizations

"""

import os
import json
import argparse
import time
from datetime import datetime
from typing import List, Dict

from common.logger import LoggerFactory, LoggerType, LogLevel


# Initialize module logger
_logger = LoggerFactory.get_logger(
    name="visualizers.sequences_visualizer",
    logger_type=LoggerType.STANDARD,
    level=LogLevel.INFO,
)


def create_static_visualization(G, sequence, index, output_dir):
    """Create static visualization using matplotlib."""
    try:
        import matplotlib.pyplot as plt
        import networkx as nx

        plt.figure(figsize=(14, 10))

        # Use a hierarchical layout for clearer dependency visualization
        try:
            pos = nx.nx_agraph.graphviz_layout(G, prog="dot", args="-Grankdir=LR")
        except:
            # Fall back to spring layout if graphviz is not available
            pos = nx.spring_layout(G, seed=42, k=0.5)

        # Create a better color scheme for nodes based on HTTP method
        method_colors = {
            "GET": "#3498db",  # Blue
            "POST": "#2ecc71",  # Green
            "PUT": "#f39c12",  # Orange
            "PATCH": "#9b59b6",  # Purple
            "DELETE": "#e74c3c",  # Red
            "": "#95a5a6",  # Gray (default)
        }

        # Extract methods from node attributes
        colors = []
        for node, attrs in G.nodes(data=True):
            method = attrs.get("method", "").upper()
            colors.append(method_colors.get(method, method_colors[""]))

        # Draw nodes with better styling
        nx.draw_networkx_nodes(
            G,
            pos,
            node_color=colors,
            node_size=2500,
            alpha=0.9,
            edgecolors="black",
            linewidths=1,
        )

        # Draw edges with arrow styling
        nx.draw_networkx_edges(
            G,
            pos,
            edge_color="#2c3e50",
            width=2,
            arrowsize=20,
            arrowstyle="-|>",
            connectionstyle="arc3,rad=0.1",
        )

        # Improve node labels
        nx.draw_networkx_labels(
            G, pos, font_size=11, font_weight="bold", font_color="white"
        )

        # Create better edge labels that focus on data mapping
        edge_labels = {}
        for u, v, data in G.edges(data=True):
            if data.get("data_mapping"):
                # Format the data mapping nicely
                mapping_str = ", ".join(
                    f"{k} → {v}" for k, v in data["data_mapping"].items()
                )
                edge_labels[(u, v)] = mapping_str
            else:
                # Use a short version of the reason
                reason = data.get("reason", "")
                if len(reason) > 25:
                    reason = reason[:22] + "..."
                edge_labels[(u, v)] = reason

        nx.draw_networkx_edge_labels(
            G,
            pos,
            edge_labels=edge_labels,
            font_size=9,
            font_color="#2c3e50",
            bbox=dict(facecolor="white", edgecolor="none", alpha=0.7, pad=3),
        )

        # Add title and metadata
        sequence_name = sequence.get("name", f"Sequence {index+1}")
        plt.title(f"Sequence: {sequence_name}", fontsize=16, fontweight="bold")
        plt.figtext(0.02, 0.02, sequence.get("description", ""), fontsize=10, wrap=True)
        plt.axis("off")

        # Add legend for HTTP methods
        from matplotlib.patches import Patch

        legend_elements = [
            Patch(facecolor=color, edgecolor="black", label=method)
            for method, color in method_colors.items()
            if any(n.startswith(method + " ") for n in G.nodes)
        ]
        if legend_elements:
            plt.legend(handles=legend_elements, loc="upper left", title="HTTP Methods")

        # Save visualization with high resolution
        safe_name = sequence_name.replace(" ", "_").replace("/", "_")
        viz_path = os.path.join(output_dir, f"sequence_{index+1}_{safe_name}.png")
        plt.savefig(viz_path, bbox_inches="tight", dpi=200)
        plt.close()

        _logger.info(f"  - Static visualization saved to: {os.path.basename(viz_path)}")
        return True

    except Exception as e:
        _logger.error(f"Error creating static visualization: {str(e)}")
        return False


def create_interactive_visualization(G, sequence, index, output_dir):
    """Create interactive visualization using pyvis."""
    try:
        from pyvis.network import Network

        # Create a pyvis network
        net = Network(height="800px", width="100%", notebook=False, directed=True)

        # Define a color scheme for methods
        method_colors = {
            "GET": "#3498db",  # Blue
            "POST": "#2ecc71",  # Green
            "PUT": "#f39c12",  # Orange
            "PATCH": "#9b59b6",  # Purple
            "DELETE": "#e74c3c",  # Red
            "": "#95a5a6",  # Gray (default)
        }

        # Add nodes with improved styling
        for node, attrs in G.nodes(data=True):
            method = attrs.get("method", "").upper()
            color = method_colors.get(method, method_colors[""])

            # Create HTML label with better formatting
            label = f"<b>{node}</b>"

            net.add_node(
                node,
                label=label,
                title=node,  # Tooltip
                color=color,
                shape="box",
                font={"color": "white", "size": 14, "face": "arial"},
            )

        # Add edges with improved styling and tooltips
        for source, target, data in G.edges(data=True):
            # Create descriptive tooltip
            tooltip = data.get("reason", "")

            # Format data mapping for tooltip if available
            if data.get("data_mapping"):
                mapping_str = "<br>".join(
                    f"- {k} → {v}" for k, v in data["data_mapping"].items()
                )
                tooltip += f"<br><br><b>Data Mapping:</b><br>{mapping_str}"

                # Create a short label showing the most important mapping
                first_key = next(iter(data["data_mapping"].keys()))
                label = f"{first_key}"
            else:
                label = ""

            # Add the edge
            net.add_edge(
                source,
                target,
                title=tooltip,  # Tooltip on hover
                label=label,
                arrows="to",
                color={"color": "#2c3e50", "opacity": 0.8},
                font={"size": 10},
            )

        # Configure network physics for better layout
        net.set_options(
            """
        {
          "physics": {
            "hierarchicalRepulsion": {
              "centralGravity": 0.0,
              "springLength": 150,
              "springConstant": 0.01,
              "nodeDistance": 200
            },
            "solver": "hierarchicalRepulsion",
            "stabilization": {"iterations": 100}
          },
          "layout": {
            "hierarchical": {
              "enabled": true,
              "direction": "LR",
              "sortMethod": "directed"
            }
          },
          "interaction": {
            "hover": true,
            "navigationButtons": true,
            "tooltipDelay": 100
          }
        }
        """
        )

        # Add description as a note in the HTML
        sequence_name = sequence.get("name", f"Sequence {index+1}")
        description = f"""
        <div style="max-width:800px; margin:20px auto; padding:15px; background-color:#f8f9fa; border:1px solid #ddd; border-radius:5px;">
            <h2>{sequence_name}</h2>
            <p>{sequence.get('description', '')}</p>
            <p><b>Operations:</b> {len(sequence.get('operations', []))}</p>
            <p><b>Dependencies:</b> {len(sequence.get('dependencies', []))}</p>
        </div>
        """

        # Save the interactive visualization
        safe_name = sequence_name.replace(" ", "_").replace("/", "_")
        viz_path = os.path.join(
            output_dir, f"interactive_sequence_{index+1}_{safe_name}.html"
        )

        # Generate the HTML with custom wrapper
        html_content = net.generate_html()
        html_content = html_content.replace("<body>", f"<body>{description}")

        with open(viz_path, "w", encoding="utf-8") as f:
            f.write(html_content)

        print(f"  - Interactive visualization saved to: {os.path.basename(viz_path)}")
        return True

    except Exception as e:
        print(f"Error creating interactive visualization: {str(e)}")
        return False


def create_summary_visualization(sequences, output_dir):
    """Create a summary visualization showing relationships between all sequences."""
    if not sequences:
        return False

    try:
        import matplotlib.pyplot as plt
        import networkx as nx
        import numpy as np

        # Create a graph for the summary view
        G = nx.DiGraph()

        # Add all sequences as nodes
        for i, seq in enumerate(sequences):
            seq_name = seq.get("name", f"Sequence {i+1}")
            G.add_node(
                seq_name,
                description=seq.get("description", ""),
                operation_count=len(seq.get("operations", [])),
                dependency_count=len(seq.get("dependencies", [])),
            )

        # Find relationships between sequences by analyzing operations
        operations_to_sequences = {}
        for i, seq in enumerate(sequences):
            seq_name = seq.get("name", f"Sequence {i+1}")
            for op in seq.get("operations", []):
                if op not in operations_to_sequences:
                    operations_to_sequences[op] = []
                operations_to_sequences[op].append(seq_name)

        # Add edges for sequences that share operations
        edges_added = set()
        for op, seq_names in operations_to_sequences.items():
            if len(seq_names) > 1:
                for i in range(len(seq_names)):
                    for j in range(i + 1, len(seq_names)):
                        edge = (seq_names[i], seq_names[j])
                        if edge not in edges_added and edge[::-1] not in edges_added:
                            G.add_edge(
                                seq_names[i], seq_names[j], operation=op, weight=1
                            )
                            edges_added.add(edge)

        # Only continue if there are relationships to visualize
        if not G.edges():
            # No relationships between sequences
            print(
                "No relationships between sequences detected for summary visualization."
            )
            return False

        # Create a colorful visualization
        plt.figure(figsize=(16, 12))

        # Use spring layout for this graph
        pos = nx.spring_layout(G, seed=42, k=0.3)

        # Size nodes based on operation count
        node_sizes = [G.nodes[n]["operation_count"] * 200 + 1000 for n in G.nodes()]

        # Use a colorful scheme for nodes
        import matplotlib.cm as cm

        colormap = cm.get_cmap("viridis", len(G.nodes()))
        node_colors = [colormap(i) for i in range(len(G.nodes()))]

        # Draw nodes
        nx.draw_networkx_nodes(
            G,
            pos,
            node_color=node_colors,
            node_size=node_sizes,
            alpha=0.8,
            edgecolors="black",
            linewidths=1,
        )

        # Draw edges with varying thickness based on number of shared operations
        edge_weights = [G[u][v].get("weight", 1) * 2 for u, v in G.edges()]
        nx.draw_networkx_edges(
            G,
            pos,
            width=edge_weights,
            alpha=0.6,
            edge_color="gray",
            style="dashed",
            connectionstyle="arc3,rad=0.2",
            arrows=False,
        )

        # Draw labels with better visibility
        nx.draw_networkx_labels(
            G,
            pos,
            font_size=10,
            font_weight="bold",
            bbox=dict(facecolor="white", edgecolor="none", alpha=0.7, pad=5),
        )

        # Add title and explanation
        plt.title("Operation Sequence Relationships", fontsize=16, fontweight="bold")
        plt.figtext(
            0.5,
            0.02,
            "Connections indicate sequences that share common operations.\n"
            "Node size represents the number of operations in each sequence.",
            fontsize=12,
            ha="center",
        )
        plt.axis("off")

        # Save the summary visualization
        summary_viz_path = os.path.join(
            output_dir, "sequence_relationships_summary.png"
        )
        plt.savefig(summary_viz_path, bbox_inches="tight", dpi=200)
        plt.close()

        print(
            f"  - Summary visualization of all sequences saved to: {os.path.basename(summary_viz_path)}"
        )
        return True

    except Exception as e:
        print(f"Error creating summary visualization: {str(e)}")
        return False


def visualize_sequences(
    sequences: List[Dict],
    output_dir: str,
    visualization_type: str = "all",
    max_sequences: int = 10,
) -> bool:
    """
    Generate visualizations of operation sequences from JSON data.

    Args:
        sequences: List of operation sequences (as dictionaries)
        output_dir: Directory to save output
        visualization_type: Type of visualization (static, interactive, all)
        max_sequences: Maximum number of sequences to visualize

    Returns:
        True if successful, False otherwise
    """
    try:
        import networkx as nx
        import matplotlib.pyplot as plt
        import numpy as np

        # Try to import optional interactive visualization libraries
        try:
            import plotly.graph_objects as go
            from pyvis.network import Network

            has_interactive = True
        except ImportError:
            has_interactive = False
            if visualization_type in ["interactive", "all"]:
                print(
                    "Interactive visualization requires plotly and pyvis. "
                    "Install with: pip install plotly pyvis"
                )
                print("Falling back to static visualization.")
                visualization_type = "static"

        if not sequences:
            print("No sequences to visualize.")
            return False

        # Create visualization subdirectory
        os.makedirs(output_dir, exist_ok=True)

        # Limit number of sequences to visualize
        sequences_to_visualize = sequences[:max_sequences]
        print(
            f"\nGenerating visualizations for {len(sequences_to_visualize)} sequences"
        )

        # Create summary visualization showing all sequence relationships
        success = create_summary_visualization(sequences_to_visualize, output_dir)

        # Process each sequence with improved visualization
        for i, sequence in enumerate(sequences_to_visualize):
            print(
                f"Creating visualization for sequence {i+1}: {sequence.get('name', f'Sequence {i+1}')}"
            )

            # Create a directed graph for the sequence
            G = nx.DiGraph()

            # Add operations as nodes with metadata
            for op in sequence.get("operations", []):
                # Extract HTTP method from operation
                method = op.split(" ")[0] if " " in op else ""
                path = op[len(method) + 1 :] if " " in op else op

                # Add node with attributes
                G.add_node(op, method=method, path=path)

            # Add dependencies as edges
            for dep in sequence.get("dependencies", []):
                # Make sure we're handling a dictionary
                if isinstance(dep, dict):
                    source_op = dep.get("source_operation")
                    target_op = dep.get("target_operation")
                    reason = dep.get("reason", "")
                    data_mapping = dep.get("data_mapping", {})

                    # Only add edge if both source and target exist
                    if source_op and target_op:
                        G.add_edge(
                            target_op,
                            source_op,
                            reason=reason,
                            data_mapping=data_mapping,
                        )

            # Only visualize if we have nodes
            if G.nodes():
                # 1. Static visualization with matplotlib
                if visualization_type in ["static", "all"]:
                    success = create_static_visualization(G, sequence, i, output_dir)

                # 2. Interactive visualization with pyvis/plotly
                if visualization_type in ["interactive", "all"] and has_interactive:
                    success = create_interactive_visualization(
                        G, sequence, i, output_dir
                    )

        print(f"\nVisualizations saved to: {output_dir}")
        return True

    except ImportError:
        print(
            "Visualization requires matplotlib and networkx. "
            "Install with: pip install matplotlib networkx"
        )
        print("For interactive visualizations, also install: pip install plotly pyvis")
        return False
    except Exception as e:
        print(f"Error creating visualization: {str(e)}")
        return False


def main():
    """Main function to run the sequences visualizer."""
    parser = argparse.ArgumentParser(
        description="Create visualizations from operation sequences JSON"
    )
    parser.add_argument(
        "--input",
        "-i",
        type=str,
        required=True,
        help="Path to the operation_sequences.json file",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        default="",
        help="Output directory for visualizations (default: creates a timestamped directory)",
    )
    parser.add_argument(
        "--type",
        "-t",
        choices=["static", "interactive", "all"],
        default="all",
        help="Type of visualizations to generate (default: all)",
    )
    parser.add_argument(
        "--max",
        "-m",
        type=int,
        default=10,
        help="Maximum number of sequences to visualize (default: 10)",
    )
    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.input):
        print(f"Error: Input file not found: {args.input}")
        return 1

    # Create output directory (with timestamp if not specified)
    if args.output:
        output_dir = args.output
    else:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = os.path.join("output", "visualizations", timestamp)

    os.makedirs(output_dir, exist_ok=True)

    # Load operation sequences from JSON file
    print(f"Loading operation sequences from: {args.input}")
    try:
        with open(args.input, "r") as f:
            data = json.load(f)
    except Exception as e:
        print(f"Error loading input file: {str(e)}")
        return 1

    # Extract sequences from the loaded data
    sequences = []
    if isinstance(data, dict) and "sequences" in data:
        sequences = data["sequences"]
    elif isinstance(data, list):
        sequences = data

    if not sequences:
        print("No operation sequences found in the input file")
        return 1

    print(f"Found {len(sequences)} operation sequences")

    # Ask user if they want to install missing dependencies
    try:
        import matplotlib
        import networkx
    except ImportError:
        print("\nVisualization requires matplotlib and networkx.")
        install = input("Would you like to install these packages now? (y/N): ").lower()
        if install == "y":
            import subprocess

            subprocess.call(["pip", "install", "matplotlib", "networkx"])
            print("Required packages installed. Continuing with visualization...")
        else:
            print("Exiting due to missing dependencies.")
            return 1

    if args.type in ["interactive", "all"]:
        try:
            import plotly
            import pyvis
        except ImportError:
            print("\nInteractive visualization requires plotly and pyvis.")
            install = input(
                "Would you like to install these packages now? (y/N): "
            ).lower()
            if install == "y":
                import subprocess

                subprocess.call(["pip", "install", "plotly", "pyvis"])
                print(
                    "Required packages installed. Continuing with interactive visualization..."
                )
            else:
                print("Falling back to static visualization.")
                args.type = "static"

    # Generate visualizations
    start_time = time.time()
    success = visualize_sequences(
        sequences=sequences,
        output_dir=output_dir,
        visualization_type=args.type,
        max_sequences=args.max,
    )

    if success:
        print(f"\nVisualization completed in {time.time() - start_time:.2f} seconds")
        print(f"Output directory: {output_dir}")
    else:
        print("\nVisualization failed")
        return 1

    return 0


if __name__ == "__main__":
    exit_code = main()
    exit(exit_code)
